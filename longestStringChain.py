"""The question gives a list of strings and we are to return an array of the longest string chain. Now two strings form a string chain 
if by removing a single letter from one string, you get the other string. This means first of all that you need more than one strings 
to form a string chain and also that successive strings in the string chain differ in length by 1. The approach this solution takes is 
to realize that each string in a string chain is the longest string in its own string chain. So if we started from the shortest string 
in the chain, it would be part of a chain that includes itself and is followed by the empty string in the chain. Now obviously that 
technically doesnt constitute a chain but is the base case. Then the penultimate string in the chain will point to this shortest string 
and so on and so forth. The algorithm starts then by sorting the input strings by length. This allows us to start finding the shortest 
string chains first and use them to build up longer string chains. It also allows us to compare lengths of chains in cases where removing 
different letters from a string yields different next string in chains of different lengths. We also dump all the input strings in a 
specialized hashtable for constant time lookup. Anyway with the sorted list of strings, we iterate and at each string we iterate through 
that string, generate new substrings with one letter removed and for each new substring we check to see if it appears in the list using
the hashtable. If we don't find any substring, we simply note that the chain starting at that string has a length of 1. If we find the 
substring, then we can add 1 to the length of the chain beginning at the substriing and this becomes the chain length for the original 
string. In cases were different substrings of the same string lead to different chain lengths, we keep the chain that has the longest 
length. At the end we start from the string that begins the longest chain and then by backtracking to the string it points to, which is 
the one that comes after it in the longest chain, we are able to build the chain until we reach the last string in the chain which should 
point to the empty string and have a chain length of 1."""
#O(n*m^2 + nlog(n)) time | O(nm) space
def longestStringChain(strings):
    stringChains = {} #hashtable that maps each string to the next string in the chain starting at the key string plus the chain length
    for string in strings: #loop to actually populate the hashtable
        stringChains[string] = {"nextString": "","maxChainLength": 1} #initialize each string to the base case; point to "", length = 1

    sortedStrings = sorted(strings,key=len)  #next is to sort the input list of strings based on their length
    for string in sortedStrings: #next for each string, generate substrings, find the next substring in the chain and the chain length
        findLongestStringChain(string,stringChains) #helper function to update hashtable with next string in chain and chain length
    
    return buildLongestStringChain(strings,stringChains)

def findLongestStringChain(string,stringChains):
    for i in range(len(string)): #iterate through every letter
        smallerString = getSmallerString(string,i) #generate substring by removing letter at index i, logic abstraction with helper func
        if smallerString not in stringChains: #if the generated substring isnt in the original list, via hashtable
            continue #do nothing, just move on to next substring generated by removing the next letter in string
        tryUpdateLongestStringChain(string,smallerString,stringChains) #if the substring in hashtable, update next in chain, maxlength

def getSmallerString(string,index):
    return string[0:index] + string[index+1:] #return a string slice and concatenate that excludes character at index

def tryUpdateLongestStringChain(currentString,smallerString,stringChains):
    smallerStringChainLength = stringChains[smallerString]["maxChainLength"] #access the length of possible next string
    currentStringChainLength = stringChains[currentString]["maxChainLength"] #access the current length of chain at string
    if smallerStringChainLength + 1 > currentStringChainLength: #if pointing to smallerstring yields a longer chain at string
        stringChains[currentString]["maxChainLength"] = smallerStringChainLength + 1 #then update length of chain at string
        stringChains[currentString]["nextString"] = smallerString #update the next string pointed to

def buildLongestStringChain(strings,stringChains):
    maxChainLength = 0 #initialize the length of the longest string chain
    chainStartingString = ""
    for string in strings: #first find the string that starts the longest chain length
        if stringChains[string]["maxChainLength"] > maxChainLength:
            maxChainLength = stringChains[string]["maxChainLength"]
            chainStartingString = string
    ourLongestStringChain = []
    currentString = chainStartingString
    while currentString != "": #loop condition use the base case
        ourLongestStringChain.append(currentString)
        currentString = stringChains[currentString]["nextString"]
    return [] if len(ourLongestStringChain) == 1 else ourLongestStringChain



strings = ["abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"]
print(longestStringChain(strings))
